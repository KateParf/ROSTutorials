**Написание простого издателя и подписчика (C++)**

Узлы — это исполняемые процессы, которые взаимодействуют через граф ROS. В этом руководстве узлы будут передавать друг другу информацию в виде строковых сообщений по теме . В качестве примера здесь используется простая система «говорящего» и «слушающего»; один узел публикует данные, а другой подписывается на тему, чтобы иметь возможность получать эти данные.

**Задачи**

**1 Создать пакет**

Откройте новый терминал и установите ROS 2, чтобы ros2команды работали.

Перейдите в ros2_wsкаталог, созданный в предыдущем уроке .

Напоминаем, что пакеты должны создаваться в srcкаталоге, а не в корне рабочей области. Итак, перейдите в ros2_ws/srcи выполните команду создания пакета:

~~~
ros2 pkg create --build-type ament_cmake --license Apache-2.0 cpp_pubsub
~~~

Ваш терминал вернет сообщение, подтверждающее создание вашего пакета cpp_pubsubи всех необходимых для него файлов и папок.

**2 Напишите узел издателя**

Загрузите пример кода говорящего, введя следующую команду:

~~~
wget -O publisher_lambda_function.cpp https://raw.githubusercontent.com/ros2/examples/rolling/rclcpp/topics/minimal_publisher/lambda.cpp
~~~

Теперь будет новый файл с именем publisher_lambda_function.cpp. Откройте файл с помощью предпочитаемого вами текстового редактора.

~~~
#include <chrono>
#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace std::chrono_literals;

/* This example creates a subclass of Node and uses a fancy C++11 lambda
* function to shorten the callback syntax, at the expense of making the
* code somewhat more difficult to understand at first glance. */

class MinimalPublisher : public rclcpp::Node
{
public:
  MinimalPublisher()
  : Node("minimal_publisher"), count_(0)
  {
    publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
    auto timer_callback =
      [this]() -> void {
        auto message = std_msgs::msg::String();
        message.data = "Hello, world! " + std::to_string(this->count_++);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
        this->publisher_->publish(message);
      };
    timer_ = this->create_wall_timer(500ms, timer_callback);
  }

private:
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
  size_t count_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<MinimalPublisher>());
  rclcpp::shutdown();
  return 0;
}
~~~

**2.1 Проверьте код**

Верхняя часть кода включает стандартные заголовки C++, которые вы будете использовать. После стандартных заголовков C++ идет include rclcpp/rclcpp.hpp, который позволяет вам использовать наиболее распространенные части системы ROS 2. Последний — std_msgs/msg/string.hpp, который включает встроенный тип сообщения, который вы будете использовать для публикации данных.

~~~
#include <chrono>
#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace std::chrono_literals;
~~~

Эти линии представляют зависимости узла. Помните, что зависимости должны быть добавлены к package.xmlи CMakeLists.txt, что вы сделаете в следующем разделе.

Следующая строка создает класс узла MinimalPublisherпутем наследования от rclcpp::Node. Каждый thisэлемент кода ссылается на узел.

class MinimalPublisher : public rclcpp::Node
Открытый конструктор называет узел minimal_publisherи инициализируется count_значением 0. Внутри конструктора издатель инициализируется с Stringтипом сообщения, именем темы topicи требуемым размером очереди для ограничения сообщений в случае резервного копирования. Затем объявляется вызываемая лямбда-функция . Она выполняет захват по ссылке текущего объекта , не принимает входных аргументов и возвращает void. Функция создает новое сообщение типа , устанавливает его данные с помощью нужной строки и публикует его. Макрос гарантирует, что каждое опубликованное сообщение будет выведено на консоль. Наконец, инициализируется, что заставляет функцию выполняться дважды в секунду.timer_callbackthistimer_callbackStringRCLCPP_INFOtimer_timer_callback

~~~
public:
  MinimalPublisher()
  : Node("minimal_publisher"), count_(0)
  {
    publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
    auto timer_callback =
      [this]() -> void {
        auto message = std_msgs::msg::String();
        message.data = "Hello, world! " + std::to_string(this->count_++);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
        this->publisher_->publish(message);
      };
    timer_ = this->create_wall_timer(500ms, timer_callback);
  }
~~~

В нижней части класса находится объявление полей таймера, издателя и счетчика.

~~~
private:
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
  size_t count_;
После MinimalPublisherкласса следует main, где узел фактически выполняется. rclcpp::initинициализирует ROS 2 и rclcpp::spinначинает обработку данных из узла, включая обратные вызовы от таймера.

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<MinimalPublisher>());
  rclcpp::shutdown();
  return 0;
}
~~~
